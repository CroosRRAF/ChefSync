import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://127.0.0.1:8000';

// Create axios instance with default config
const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000, // 10 second timeout
});

// Add request interceptor to include auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('chefsync_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add response interceptor to handle token refresh
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('chefsync_refresh_token');
        if (refreshToken) {
          const response = await api.post('/api/auth/token/refresh/', {
            refresh: refreshToken,
          });
          
          const { access } = response.data;
          localStorage.setItem('chefsync_token', access);
          
          // Retry original request with new token
          originalRequest.headers.Authorization = `Bearer ${access}`;
          return api(originalRequest);
        }
      } catch (refreshError) {
        // Refresh failed, redirect to login
        localStorage.removeItem('chefsync_token');
        localStorage.removeItem('chefsync_refresh_token');
        window.location.href = '/auth/login';
      }
    }

    return Promise.reject(error);
  }
);

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterData {
  name: string;
  email: string;
  password: string;
  confirm_password: string;
  phone_no?: string;
  role: 'customer' | 'cook' | 'delivery_agent';
  address?: string;
}

export interface User {
  user_id: string;
  name: string;
  email: string;
  phone_no?: string;
  address?: string;
  role: 'customer' | 'cook' | 'delivery_agent';
  role_display: string;
  profile_image?: string;
  email_verified: boolean;
  created_at: string;
  updated_at: string;
  profile_data?: any;
}

export interface AuthResponse {
  message: string;
  access: string;
  refresh: string;
  user: User;
  redirect?: string;
}

export interface RegisterResponse {
  message: string;
  user_id: string;
}

const authService = {
  getRoleBasedPath(role: string): string {
    switch (role) {
      case 'customer':
        return '/customer/dashboard';
      case 'cook':
        return '/cook/dashboard';
      case 'delivery_agent':
        return '/delivery/dashboard';
      case 'admin':
        return '/admin/dashboard';
      default:
        return '/';
    }
  },

  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
      // Clear any existing tokens before login
      localStorage.removeItem('chefsync_token');
      localStorage.removeItem('chefsync_refresh_token');
      localStorage.removeItem('auth_redirect');
      
      const response = await api.post<AuthResponse>('/api/auth/login/', credentials);
      
      if (!response.data.access || !response.data.refresh) {
        throw new Error('Invalid response from server: missing authentication tokens');
      }
      
      // Store tokens
      localStorage.setItem('chefsync_token', response.data.access);
      localStorage.setItem('chefsync_refresh_token', response.data.refresh);

      // Use the server-provided redirect path or fallback to role-based path
      const redirectPath = response.data.redirect || this.getRoleBasedPath(response.data.user.role);
      localStorage.setItem('auth_redirect', redirectPath);
      
      return response.data;
    } catch (error: any) {
      console.error('Login error:', error.response?.data || error.message || error);
      
      if (error.code === 'ECONNABORTED') {
        throw new Error('The request timed out. Please try again.');
      }
      
      if (!error.response) {
        throw new Error('Network Error: Unable to connect to the server. Please check your internet connection and try again.');
      }

      if (error.response?.status === 429) {
        throw new Error('Too many login attempts. Please try again later.');
      }

      if (error.response?.status === 401) {
        throw new Error('Invalid email or password.');
      }

      if (error.response?.status === 403) {
        throw new Error('Your account is locked. Please try again later.');
      }

      if (error.response?.data) {
        if (error.response.data.non_field_errors) {
          throw new Error(error.response.data.non_field_errors[0]);
        } else if (error.response.data.email) {
          throw new Error(`Email: ${error.response.data.email[0]}`);
        } else if (error.response.data.password) {
          throw new Error(`Password: ${error.response.data.password[0]}`);
        } else if (error.response.data.error) {
          throw new Error(error.response.data.error);
        }
      }
      
      throw new Error('Login failed. Please try again.');
    }
  },

  async register(data: RegisterData): Promise<RegisterResponse> {
    try {
      const response = await api.post<RegisterResponse>('/api/auth/register/', data);
      return response.data;
    } catch (error: any) {
      if (error.response?.data) {
        throw new Error(error.response.data.error || error.response.data.message || 'Registration failed');
      }
      throw new Error('Network error occurred');
    }
  },

  async logout(): Promise<void> {
    try {
      const refreshToken = localStorage.getItem('chefsync_refresh_token');
      if (refreshToken) {
        await api.post('/api/auth/logout/', { refresh: refreshToken });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.removeItem('chefsync_token');
      localStorage.removeItem('chefsync_refresh_token');
    }
  },

  isAuthenticated(): boolean {
    return !!localStorage.getItem('chefsync_token');
  },

  getToken(): string | null {
    return localStorage.getItem('chefsync_token');
  },

  getRefreshToken(): string | null {
    return localStorage.getItem('chefsync_refresh_token');
  }
};

export default authService;

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://127.0.0.1:8000';

// Create axios instance with default config
const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000, // 10 second timeout
});

// Add request interceptor to include auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('chefsync_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Add response interceptor to handle token refresh
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('chefsync_refresh_token');
        if (refreshToken) {
          const response = await api.post('/token/refresh/', {
            refresh: refreshToken,
          });
          
          const { access } = response.data;
          localStorage.setItem('chefsync_token', access);
          
          // Retry original request with new token
          originalRequest.headers.Authorization = `Bearer ${access}`;
          return api(originalRequest);
        }
      } catch (refreshError) {
        // Refresh failed, redirect to login
        localStorage.removeItem('chefsync_token');
        localStorage.removeItem('chefsync_refresh_token');
        window.location.href = '/auth/login';
      }
    }

    return Promise.reject(error);
  }
);

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterData {
  name: string;
  email: string;
  password: string;
  confirm_password: string;
  phone_no?: string;
  role: 'customer' | 'cook' | 'delivery_agent';
  address?: string;
}

export interface User {
  user_id: string;
  name: string;
  email: string;
  phone_no?: string;
  address?: string;
  role: 'customer' | 'cook' | 'delivery_agent';
  role_display: string;
  profile_image?: string;
  email_verified: boolean;
  created_at: string;
  updated_at: string;
  profile_data?: any;
}

export interface AuthResponse {
  message: string;
  access: string;
  refresh: string;
  user: User;
  redirect?: string;
}

export interface RegisterResponse {
  message: string;
  user_id: string;
}

export interface EmailVerificationData {
  token: string;
}

export interface PasswordResetRequestData {
  email: string;
}

export interface PasswordResetConfirmData {
  token: string;
  new_password: string;
  confirm_new_password: string;
}

export interface GoogleOAuthData {
  access_token: string;
  id_token: string;
}

const authService = {
  getRoleBasedPath(role: string): string {
    switch (role) {
      case 'customer':
        return '/customer/dashboard';
      case 'cook':
        return '/cook/dashboard';
      case 'delivery_agent':
        return '/delivery/dashboard';
      case 'admin':
        return '/admin/dashboard';
      default:
        return '/';
    }
  },

  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    try {
      // Clear any existing tokens before login
      localStorage.removeItem('chefsync_token');
      localStorage.removeItem('chefsync_refresh_token');
      localStorage.removeItem('auth_redirect');
      
      const response = await api.post<AuthResponse>('/api/auth/login/', credentials);
      
      if (!response.data.access || !response.data.refresh) {
        throw new Error('Invalid response from server: missing authentication tokens');
      }
      
      // Store tokens
      localStorage.setItem('chefsync_token', response.data.access);
      localStorage.setItem('chefsync_refresh_token', response.data.refresh);

      // Use the server-provided redirect path or fallback to role-based path
      const redirectPath = response.data.redirect || this.getRoleBasedPath(response.data.user.role);
      localStorage.setItem('auth_redirect', redirectPath);
      
      return response.data;
    } catch (error: any) {
      console.error('Login error:', error.response?.data || error.message || error);
      
      if (error.code === 'ECONNABORTED') {
        throw new Error('The request timed out. Please try again.');
      }
      
      if (!error.response) {
        throw new Error('Network Error: Unable to connect to the server. Please check your internet connection and try again.');
      }

      if (error.response?.status === 429) {
        throw new Error('Too many login attempts. Please try again later.');
      }

      if (error.response?.status === 401) {
        throw new Error('Invalid email or password.');
      }

      if (error.response?.status === 403) {
        throw new Error('Your account is locked. Please try again later.');
      }

      if (error.response?.data) {
        if (error.response.data.non_field_errors) {
          throw new Error(error.response.data.non_field_errors[0]);
        } else if (error.response.data.email) {
          throw new Error(`Email: ${error.response.data.email[0]}`);
        } else if (error.response.data.password) {
          throw new Error(`Password: ${error.response.data.password[0]}`);
        } else if (error.response.data.error) {
          throw new Error(error.response.data.error);
        }
      }
      
      throw new Error('Login failed. Please try again.');
    }
      throw new Error('Login failed. Please try again.');
    }
  }

  async register(data: RegisterData): Promise<RegisterResponse> {
    try {
      const response = await api.post<RegisterResponse>('/api/auth/register/', data);
      return response.data;
    } catch (error: any) {
      if (error.response?.data) {
        throw new Error(error.response.data.error || error.response.data.message || 'Registration failed');
      }
      throw new Error('Network error occurred');
    }
  }

  async logout(): Promise<void> {
    try {
      const refreshToken = localStorage.getItem('chefsync_refresh_token');
      if (refreshToken) {
        await api.post('/logout/', { refresh: refreshToken });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      // Always clear local storage
      localStorage.removeItem('chefsync_token');
      localStorage.removeItem('chefsync_refresh_token');
    }
  }

  async verifyEmail(data: EmailVerificationData): Promise<{ message: string }> {
    const response = await api.post<{ message: string }>('/verify-email/', data);
    return response.data;
  }

  async requestPasswordReset(data: PasswordResetRequestData): Promise<{ message: string }> {
    const response = await api.post<{ message: string }>('/password/reset/', data);
    return response.data;
  }

  async confirmPasswordReset(data: PasswordResetConfirmData): Promise<{ message: string }> {
    const response = await api.post<{ message: string }>('/password/reset/confirm/', data);
    return response.data;
  }

  async googleOAuth(data: GoogleOAuthData): Promise<AuthResponse> {
    const response = await api.post<AuthResponse>('/google/login/', data);
    
    // Store tokens
    localStorage.setItem('chefsync_token', response.data.access);
    localStorage.setItem('chefsync_refresh_token', response.data.refresh);
    
    return response.data;
  }

  async getProfile(): Promise<User> {
    const response = await api.get<User>('/profile/');
    return response.data;
  }

  async updateProfile(data: Partial<User>): Promise<{ message: string; user: User }> {
    const response = await api.put<{ message: string; user: User }>('/profile/update/', data);
    return response.data;
  }

  async changePassword(oldPassword: string, newPassword: string, confirmNewPassword: string): Promise<{ message: string }> {
    const response = await api.post<{ message: string }>('/password/change/', {
      old_password: oldPassword,
      new_password: newPassword,
      confirm_new_password: confirmNewPassword,
    });
    return response.data;
  }

  async refreshToken(): Promise<{ access: string; refresh: string }> {
    const refreshToken = localStorage.getItem('chefsync_refresh_token');
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await api.post<{ access: string; refresh: string }>('/token/refresh/', {
      refresh: refreshToken,
    });

    // Update stored tokens
    localStorage.setItem('chefsync_token', response.data.access);
    localStorage.setItem('chefsync_refresh_token', response.data.refresh);

    return response.data;
  }

  // Helper method to check if user is authenticated
  isAuthenticated(): boolean {
    return !!localStorage.getItem('chefsync_token');
  }

  // Helper method to get current token
  getToken(): string | null {
    return localStorage.getItem('chefsync_token');
  }

  // Helper method to get current refresh token
  getRefreshToken(): string | null {
    return localStorage.getItem('chefsync_refresh_token');
  }

  // Helper method to get role-based redirect path
  getRoleBasedPath(role: string): string {
    switch (role) {
      case 'customer':
        return '/customer/dashboard';
      case 'cook':
        return '/cook/dashboard';
      case 'delivery_agent':
        return '/delivery/dashboard';
      case 'admin':
        return '/admin/dashboard';
      default:
        return '/';
    }
  }
}

export default authService;
